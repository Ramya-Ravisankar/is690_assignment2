
6. **Explain the functioning of JWT (JSON Web Tokens) in user authentication. How are JWTs generated, encoded, and used within the project?**
   - [Read this article and link to the code in the user management.](https://supertokens.com/blog/what-is-jwt)
   - Include a code snippet showing how JWTs are implemented in the project.

### Answer
JWT authorization uses a JWT to represent the user's identity and access rights. The JWT is usually generated by the authentication server after the user logs in and contains the user's identity and access rights. The JWT is then sent with every API request as a bearer token in the authorization header.

When it comes to API authentication and server-to-server authorization, JSON web token (JWT) is particularly a useful technology. In terms of Single Sign-On (SSO), it means that a service provider can receive trustworthy information from the authentication server.
By sharing a secret key with the Identity Provider, the Service Provider can hash a part of a token it receives and compare it to the signature of the token. Now, if that result matches the signature, the SP knows that the information provided has come from the other entity possessing the key.

1) User sign-in using username and password.
2) The authentication server verifies the credentials and issues a JWT signed using a private key.
3) Moving forward, the client will use the JWT to access protected resources by passing the JWT in the HTTP Authorization header.
4) The resource server then verifies the authenticity of the token using the public key.

The Identity Provider generates a JWT certifying user identity, and the resource server decodes and verifies the authenticity of the token using the public key. Since the tokens are used for authorization and authentication in future requests and API calls great care must be taken to prevent security issues.These tokens shouldn’t be stored in publicly accessible areas like the browser’s local storage or cookies. In case there are no other choices, then the payload should be encrypted.

## JSON Web Tokens (JWTs) have three parts: a header, payload, and signature:
1) Header: Contains the token type and the signing algorithm being used. The header and payload are both Base64-URL encoded JSON.
2) Payload: Contains claims, which are statements about an entity and additional data.
3) Signature: A cryptographic signature that verifies the authenticity of the token. It's created by hashing the encoded header and payload with a secret key using the hashing algorithm defined in the header. The signature is then appended to the header and payload with a dot to form the actual token.

## Gist of JWT :
==> JWT (JSON Web Tokens) is a method to transmit information securely as a JSON object and are commonly used for authentication and authorization in web applications.

==> A JWT is generated with the user's information by the server when a user authenticates with the server.

==> A specific algorithm, such as HS256 or RSA, encodes the JWT into a string with a secret key.

==> A JWT can be stored by the client in local storage or in a cookie, can have an expiration time, and can have an authorization role.


## Code Snippet - jwt implementation in our project:
[jwt_service.py](/app/services/jwt_service.py)

``
from datetime import datetime, timedelta, timezone
import logging
import jwt
from settings.config import settings

# Configure logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def create_access_token(*, data: dict, expires_delta: timedelta = None):
    logging.debug(f"Starting token creation. Data: {data}")
    to_encode = data.copy()

    # Convert 'role' to uppercase before encoding the JWT, if present
    if 'role' in to_encode:
        to_encode['role'] = to_encode['role'].upper()
        logging.debug(f"'role' modified to uppercase: {to_encode['role']}")

    # Check for required fields in the token payload
    if 'user_id' not in to_encode:
        logging.error("Missing 'user_id' in token payload")
        raise ValueError("user_id is required in the token payload")

    # Set the expiration time for the token using timezone-aware datetime
    if expires_delta is None:
        expires_delta = timedelta(minutes=settings.access_token_expire_minutes)
    expire = datetime.now(timezone.utc) + expires_delta
    to_encode.update({"exp": expire.timestamp()})  # Store as timestamp
    logging.debug(f"Token expiration set to {expire.isoformat()}")

    # Encode the JWT
    try:
        encoded_jwt = jwt.encode(to_encode, settings.jwt_secret_key, algorithm=settings.jwt_algorithm)
        logging.info(f"JWT created with expiration at {expire.isoformat()}")
        logging.debug(f"Encoded JWT: {encoded_jwt}")

        # Immediate decoding test to verify correctness right after creation
        try:
            decoded = jwt.decode(encoded_jwt, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
            logging.info("Immediate decode result: {}".format(decoded))
            logging.debug("Immediate decode check: {}".format(decoded))
        except jwt.ExpiredSignatureError:
            logging.error("Token already expired upon creation, check system clock.")
        except jwt.InvalidTokenError as e:
            logging.error(f"Token invalid right after creation: {e}")
        except jwt.PyJWTError as e:
            logging.error(f"Error during immediate token decode: {e}")

        return encoded_jwt
    except Exception as e:
        logging.error(f"Error encoding JWT: {e}")
        raise

def decode_token(token: str):
    logging.info(f"Attempting to decode token: {token}")
    try:
        decoded = jwt.decode(token, settings.jwt_secret_key, algorithms=[settings.jwt_algorithm])
        logging.info("JWT decoded successfully")
        logging.debug(f"Decoded JWT payload: {decoded}")

        # Comparing timestamps using UTC now
        current_timestamp = datetime.now(timezone.utc).timestamp()
        exp_timestamp = decoded.get("exp")

        logging.info(f"Current timestamp: {current_timestamp}")
        logging.info(f"Token expiration timestamp: {exp_timestamp}")

        if current_timestamp > exp_timestamp:
            logging.warning("Token has expired.")
            return None

        return decoded
    except jwt.ExpiredSignatureError:
        logging.warning("Attempt to access with expired token.")
        return None
    except jwt.InvalidTokenError:
        logging.error("Invalid token detected.")
        return None
    except jwt.PyJWTError as e:
        logging.error(f"JWT decoding failed: {e}")
        return None

```

   [Return back to answer.md](/answer.md)